#############pract1====Aim: Implement Breadth First Search Algorithm to solve given problem.
from queue import Queue
romaniaMap = {
    'Arad': ['Sibiu', 'Zerind', 'Timisoara'],
    'Zerind': ['Arad', 'Oradea'],
    'Oradea': ['Zerind', 'Sibiu'],
    'Sibiu': ['Arad', 'Oradea', 'Fagaras', 'Rimnicu'],
    'Timisoara': ['Arad', 'Lugoj'],
    'Lugoj': ['Timisoara', 'Mehadia'],
    'Mehadia': ['Lugoj', 'Drobeta'],
    'Drobeta': ['Mehadia', 'Craiova'],
    'Craiova': ['Drobeta', 'Rimnicu', 'Pitesti'],
    'Rimnicu': ['Sibiu', 'Craiova', 'Pitesti'],
    'Fagaras': ['Sibiu', 'Bucharest'],
    'Pitesti': ['Rimnicu', 'Craiova', 'Bucharest'],
    'Bucharest': ['Fagaras', 'Pitesti', 'Giurgiu', 'Urziceni'],
    'Giurgiu': ['Bucharest'],
    'Urziceni': ['Bucharest', 'Vaslui', 'Hirsova'],
    'Hirsova': ['Urziceni', 'Eforie'],
    'Eforie': ['Hirsova'],
    'Vaslui': ['Iasi', 'Urziceni'],
    'Iasi': ['Vaslui', 'Neamt'],
    'Neamt': ['Iasi']
}
def bfs(startingNode, destinationNode):
    visited = {}
    distance = {}
    parent = {}
    bfs_traversal_output = []
    queue = Queue()
    for city in romaniaMap.keys():
        visited[city] = False
        parent[city] = None
        distance[city] = -1
    startingCity = startingNode
    visited[startingCity] = True
    distance[startingCity] = 0
    queue.put(startingCity)
    while not queue.empty():
        u = queue.get() 
        bfs_traversal_output.append(u)
        for v in romaniaMap[u]:
                if not visited[v]:
                    visited[v] = True
                    parent[v] = u
                    distance[v] = distance[u] + 1
                    queue.put(v)
    g = destinationNode
    path = []
    while g is not None:
        path.append(g)
        g = parent[g]
    path.reverse()
    print(path)
bfs('Arad', 'Bucharest')

________________________________________________________________

###Practical No.02
##########Aim: Implement Recursive Best First Search Algorithm to solve given problem.

import sys
romania_map={
    'Arad': {'Zerind': 75, 'Timisoara': 118, 'Sibiu': 140},
    'Zerind': {'Arad': 75, 'Oradea': 71},
    'Timisoara': {'Arad': 118, 'Lugoj': 111},
    'Sibiu': {'Arad': 140, 'Oradea': 151, 'Fagaras': 99, 'Rimnicu Vilcea': 80},
    'Oradea': {'Zerind': 71, 'Sibiu': 151},
    'Lugoj':{'Timisoara': 111, 'Mehadia': 70},
    'Fagaras':{'Sibiu': 99, 'Bucharest': 211},
    'Rimnicu Vilcea': {'Sibiu':80 , 'Craiova': 146, 'Pitesti': 97},
    'Mehadia': {'Lugoj': 70, 'Drobeta': 75},
    'Drobeta': {'Mehadia': 75, 'Craiova': 120},
    'Craiova':{'Drobeta': 120, 'Rimnicu Vilcea': 146, 'Pitesti': 138},
    'Pitesti':{'Rimnicu Vilcea': 97, 'Craiova': 138, 'Bucharest': 101},
    'Bucharest':{'Fagaras': 211, 'Pitesti': 101}
}
heuristics ={
    'Arad': 366,
    'Zerind': 374,
    'Timisoara': 329,
    'Sibiu':253,
    'Oradea': 380,
    'Lugoj': 244,
    'Fagaras': 176,
    'Rimnicu Vilcea': 193,
    'Mebadia': 241,
    'Drobeta': 242,
    'Craiova': 160,
    'Pitesti': 100,
    'Bucharest': 0
}
def rbfs_search(start, goal, path, f_limit):
    if start==goal:
        return path
    successors = romania_map[start]
    if len(successors) == 0:
        return None
    sorted_successors= sorted(successors, key=lambda x: successors[x]+ heuristics[x])
    for city in sorted_successors:
        new_path = path + [city]
        f_value = successors [city] + heuristics[city]
        if f_value> f_limit:
            return None
        result=rbfs_search(city, goal, new_path, min(f_limit, f_value))
        if result is not None:
            return result
    return None
def recursive_best_first_search(start, goal):
    f_limit=sys.maxsize
    path=[start]
    while True:
        result= rbfs_search(start, goal, path, f_limit)
        if result is not None:
            return result
        f_limit=sys,maxsize
start_city='Arad'
goal_city='Bucharest'
path=recursive_best_first_search(start_city, goal_city)
if path is None:
    print("Path not found!")
else:
    print("Path:", path)
    print("Cost:",sum(romania_map[path[i]][path[i+1]] for i in range(len(path)-1)))

_____________________________________________________________________________________

Practical No.03
Aim: Implement A* Search Algorithm to solve given problem.

romania_graph = {
'Arad': [('Zerind', 75), ('Timisoara', 118), ('Sibiu', 140)],
'Zerind': [('Arad', 75), ('Oradea', 71)],
'Timisoara': [('Arad', 118), ('Lugoj', 111)],
'Sibiu': [('Arad', 140), ('Oradea', 151), ('Fagaras', 99), ('Rimnicu Vilcea', 80)],
'Oradea': [('Zerind', 71), ('Sibiu', 151)],
'Lugoj': [('Timisoara', 111), ('Mehadia', 70)],
'Fagaras': [('Sibiu', 99), ('Bucharest', 211)],
'Rimnicu Vilcea': [('Sibiu', 80), ('Craiova', 146), ('Pitesti', 97)],
'Mehadia': [('Lugoj', 70), ('Drobeta', 75)],
'Drobeta': [('Mehadia', 75), ('Craiova', 120)],
'Craiova': [('Drobeta', 120), ('Rimnicu Vilcea', 146), ('Pitesti', 138)],
'Pitesti': [('Rimnicu Vilcea', 97), ('Craiova', 138), ('Bucharest', 101)],
'Bucharest': [('Fagaras', 211), ('Pitesti', 101)],
}
heuristic = {
'Arad': 366,
'Bucharest': 0,
'Craiova': 160,
'Drobeta': 242,
'Fagaras': 178,
'Lugoj': 244,
'Mehadia': 241,
'Oradea': 380,
'Pitesti': 98,
'Rimnicu Vilcea': 193,
'Sibiu': 253,
'Timisoara': 329,
'Zerind': 374,
}
def a_star(start, goal):
    open_set = [(0, start)] 
    came_from = {} 
    g_score = {city: float('inf') for city in romania_graph}
    g_score[start] = 0
    while open_set:
        current_cost, current_city = min(open_set)
        open_set.remove((current_cost, current_city))
        if current_city == goal:
            path = []
            while current_city in came_from:
                path.append(current_city)
                current_city = came_from[current_city]
            path.append(start)
            return path[::-1]
        for neighbor, cost in romania_graph[current_city]:
            tentative_g_score = g_score[current_city] + cost
            if tentative_g_score < g_score[neighbor]:
                came_from[neighbor] = current_city
                g_score[neighbor] = tentative_g_score
                f_score = tentative_g_score + heuristic[neighbor]
                open_set.append((f_score, neighbor))
    return None 
start_city = 'Arad'
goal_city = 'Bucharest'
path = a_star(start_city, goal_city)
print("Optimal Path:", path)

_________________________________________________________________________________

Practical No.04
Aim: Implement Iterative Depth First Search Algorithm to solve given problem.

romania_map = {
'Arad': ['Zerind', 'Sibiu', 'Timisoara'],
'Zerind': ['Arad', 'Oradea'],
'Oradea': ['Zerind', 'Sibiu'],
'Sibiu': ['Arad', 'Oradea', 'Fagaras', 'Rimnicu Vilcea'],
'Timisoara': ['Arad', 'Lugoj'],
'Lugoj': ['Timisoara', 'Mehadia'],
'Mehadia': ['Lugoj', 'Drobeta'],
'Drobeta': ['Mehadia', 'Craiova'],
'Craiova': ['Drobeta', 'Rimnicu Vilcea', 'Pitesti'],
'Rimnicu Vilcea': ['Sibiu', 'Craiova', 'Pitesti'],
'Fagaras': ['Sibiu', 'Bucharest'],
'Pitesti': ['Rimnicu Vilcea', 'Craiova', 'Bucharest'],
'Bucharest': ['Fagaras', 'Pitesti', 'Giurgiu', 'Urziceni'],
'Giurgiu': ['Bucharest'],
'Urziceni': ['Bucharest', 'Hirsova', 'Vaslui'],
'Hirsova': ['Urziceni', 'Eforie'],
'Eforie': ['Hirsova'],
'Vaslui': ['Urziceni', 'Iasi'],
'Iasi': ['Vaslui', 'Neamt'],
'Neamt': ['Iasi']
}
def iterative_deepening_dfs(start, goal, depth_limit):
    for depth in range(depth_limit + 1):
        visited = set()
        result = depth_limited_dfs(start, goal, depth, visited)
        if result is not None:
            return result
    return None
def depth_limited_dfs(node, goal, depth, visited):
    if node == goal:
        return [node]
    if depth == 0:
        return None
    visited.add(node)
    for neighbor in romania_map[node]:
        if neighbor not in visited:
            result = depth_limited_dfs(neighbor, goal, depth - 1, visited)
            if result is not None:
                return [node] + result
    return None
start_city = 'Arad'
goal_city = 'Bucharest'
depth_limit = 10
path = iterative_deepening_dfs(start_city, goal_city, depth_limit)
if path is not None:
    print("Path found:", ' -> '.join(path))
else:
    print("Path not found within depth limit.")

_________________________________________________________________
Practical No.05
Aim: Adaboost Ensemble Learning

import pandas
from sklearn import model_selection
from sklearn.ensemble import AdaBoostClassifier
url = "https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.data.csv"
names = ['preg', 'plas', 'pres', 'skin', 'test', 'mass', 'pedi', 'age', 'class']
dataframe = pandas.read_csv(url, names=names)
array = dataframe.values
X = array[:,0:8]
Y = array[:,8]
seed = 7
num_trees = 30

model = AdaBoostClassifier(n_estimators=num_trees, random_state=seed)
results = model_selection.cross_val_score(model, X, Y)
print(results.mean())

_______________________________________________________________
Practical No.07
Aim: K-NN Algorithm

from sklearn.neighbors import KNeighborsClassifier
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score


iris = load_iris()
X = iris.data
y = iris.target


X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

k = 3 
clf = KNeighborsClassifier(n_neighbors=k)

clf.fit(X_train, y_train)

y_pred = clf.predict(X_test)

accuracy = accuracy_score(y_test, y_pred)
print(f"Accuracy: {accuracy}")
___________________________________________________

Practical No.08
Aim: Feed Forward Back Propagation Neural Network

import numpy as np
def sigmoid(x):
    return 1 / (1 + np.exp(-x))

def sigmoid_derivative(x):
    return x * (1 - x)
np.random.seed(42)
input_size = 2
hidden_size = 3
output_size = 1
weights_input_hidden = np.random.rand(input_size, hidden_size)
weights_hidden_output = np.random.rand(hidden_size, output_size)

bias_hidden = np.zeros((1, hidden_size))
bias_output = np.zeros((1, output_size))
X = np.array([[0, 0],
              [0, 1],
              [1, 0],
              [1, 1]])

y = np.array([[0], [1], [1], [0]])


epochs = 10000
learning_rate = 0.1

for epoch in range(epochs):
    hidden_layer_input = np.dot(X, weights_input_hidden) + bias_hidden
    hidden_layer_output = sigmoid(hidden_layer_input)

    output_layer_input = np.dot(hidden_layer_output, weights_hidden_output) + bias_output
    predicted_output = sigmoid(output_layer_input)

    loss = 0.5 * np.mean((predicted_output - y) ** 2)

    
    error = y - predicted_output
    output_delta = error * sigmoid_derivative(predicted_output)

    hidden_layer_error = output_delta.dot(weights_hidden_output.T)
    hidden_layer_delta = hidden_layer_error * sigmoid_derivative(hidden_layer_output)

    weights_hidden_output += hidden_layer_output.T.dot(output_delta) * learning_rate
    weights_input_hidden += X.T.dot(hidden_layer_delta) * learning_rate

    bias_output += np.sum(output_delta, axis=0, keepdims=True) * learning_rate
    bias_hidden += np.sum(hidden_layer_delta, axis=0, keepdims=True) * learning_rate

test_input = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])
predicted_output = sigmoid(np.dot(sigmoid(np.dot(test_input, weights_input_hidden) + bias_hidden), weights_hidden_output) + bias_output)

print("Predicted Output after training:")
print(predicted_output)
______________________________________________________________----

Practical No.09
Aim:
1) Implement the SVM algorithm for binary classification.


from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score

iris = datasets.load_iris()
X = iris.data
y = iris.target

X_binary = X[y != 2]
y_binary = y[y != 2]


X_train, X_test, y_train, y_test = train_test_split(X_binary, y_binary, test_size=0.2, random_state=42)


clf = SVC(kernel='linear', C=1.0)


clf.fit(X_train, y_train)


y_pred = clf.predict(X_test)


accuracy = accuracy_score(y_test, y_pred)
print(f"Accuracy: {accuracy}")


